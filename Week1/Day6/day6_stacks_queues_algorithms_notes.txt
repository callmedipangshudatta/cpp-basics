DAY 6 ‚Äî STACKS, QUEUES & STL ALGORITHMS (DSA CORE)

================================================
1) STACK (LIFO ‚Äî LAST IN, FIRST OUT)
================================================

Imagine a stack of plates üçΩÔ∏è

- You put a plate on top ‚Üí push
- You remove the top plate ‚Üí pop
- You only see the top plate ‚Üí top

You CANNOT access the middle.

-----------------------------------------------
Stack operations:
-----------------------------------------------
push(x) ‚Üí add element
pop()   ‚Üí remove top
top()   ‚Üí see top element

-----------------------------------------------
Where stacks are used:
-----------------------------------------------
- Undo / Redo
- Parentheses checking
- Function calls (call stack)
- Reversing things

================================================
2) QUEUE (FIFO ‚Äî FIRST IN, FIRST OUT)
================================================

Imagine a line at a ticket counter üéüÔ∏è

- First person enters ‚Üí first served
- No jumping allowed

-----------------------------------------------
Queue operations:
-----------------------------------------------
push(x)  ‚Üí add at back
pop()    ‚Üí remove from front
front()  ‚Üí see front element

-----------------------------------------------
Where queues are used:
-----------------------------------------------
- Scheduling
- Breadth First Search (BFS)
- Task processing

================================================
3) PRIORITY QUEUE (IMPORTANT)
================================================

Priority Queue = special queue  
Element with HIGHEST priority comes first.

-----------------------------------------------
Default behavior in C++:
-----------------------------------------------
priority_queue<int> pq;
‚Üí MAX HEAP (largest element on top)

-----------------------------------------------
Min Heap:
-----------------------------------------------
priority_queue<int, vector<int>, greater<int>> pq;

-----------------------------------------------
Where priority queue is used:
-----------------------------------------------
- Top K elements
- Dijkstra‚Äôs algorithm
- Scheduling problems

================================================
4) STL ALGORITHMS (TRUST THEM)
================================================

STL algorithms are:
- Optimized
- Tested
- Used by millions

Never re-write what STL already gives.

-----------------------------------------------
IMPORTANT ALGORITHMS:
-----------------------------------------------

sort(start, end)
‚Üí sorts range

reverse(start, end)
‚Üí reverses range

min_element(start, end)
‚Üí returns iterator to smallest element

max_element(start, end)
‚Üí returns iterator to largest element

count(start, end, value)
‚Üí counts occurrences

find(start, end, value)
‚Üí finds value (returns iterator)

================================================
5) ITERATOR RANGE (CRITICAL IDEA)
================================================

STL algorithms work on RANGES.

Range is always:
[start, end)

Meaning:
- begin() ‚Üí included
- end()   ‚Üí NOT included

This is universal in C++ STL.

================================================
6) BINARY SEARCH HELPERS
================================================

Used ONLY on SORTED containers.

-----------------------------------------------
lower_bound(x):
-----------------------------------------------
First position where x can be inserted
without breaking order.

-----------------------------------------------
upper_bound(x):
-----------------------------------------------
First position AFTER last occurrence of x.

-----------------------------------------------
Difference gives frequency in sorted array.

================================================
7) INTERVIEW RULES (MEMORIZE)
================================================

Why STL algorithms are trusted?
‚Üí Faster, safer, optimized, readable.

When to use lower_bound / upper_bound?
‚Üí When data is SORTED and you need positions,
not just existence.

================================================
8) REALITY CHECK
================================================

Good DSA coders:
- Think in containers
- Act with algorithms

Bad ones:
- Write loops for everything
- Waste time
